
#pragma once

#include <sys/types.h>

/* Declarations for required implementation functions in slash.c */
void slash_command_usage(struct slash *slash, struct slash_command *command);
char *slash_history_increment(struct slash *slash, char *ptr);
int slash_putchar(struct slash *slash, char c);
struct slash_command * slash_command_find(struct slash *slash, char *line, size_t linelen, char **args);
void slash_command_description(struct slash *slash, struct slash_command *command);

/* Define and initialize section variables */
/* __attribute__((visibility("hidden"))) prevents a symbol from linking with 
	the loading application (csh) should slash be compiled as an addin.
	In simple terms: this means the addin must define at least 1 command,
	(so "__start_slash" will be generated by GCC)
	before it can use slash as a dependency. */
extern struct slash_command __start_slash __attribute__((visibility("hidden")));
extern struct slash_command __stop_slash __attribute__((visibility("hidden")));
// extern struct slash_command __start_slash;
// extern struct slash_command __stop_slash;

typedef struct slash_section_s {
	struct slash_command * section_start;
	struct slash_command * section_stop;
	struct slash_section_s * next;
} slash_section_t;

extern slash_section_t our_slash_section __attribute__((visibility("hidden")));
extern slash_section_t * slash_section_head __attribute__((visibility("hidden")));

/* Iteration of command list */
#define slash_for_each_command(_c) \
	struct slash_command *_c;\
    for (slash_section_t *section = slash_section_head; section != NULL; section = section->next) \
        for (_c = section->section_stop - 1; _c >= section->section_start; _c--)
