
#pragma once

#include <sys/types.h>

/* Declarations for required implementation functions in slash.c */
void slash_command_usage(struct slash *slash, struct slash_command *command);
char *slash_history_increment(struct slash *slash, char *ptr);
int slash_putchar(struct slash *slash, char c);
struct slash_command * slash_command_find(struct slash *slash, char *line, size_t linelen, char **args);
void slash_command_description(struct slash *slash, struct slash_command *command);

/* Define and initialize section variables */
/* __attribute__((visibility("hidden"))) prevents the section symbols from linking with
	the loading application (csh) when compiling an addin.
	In simple terms: When used alone, this means the addin must define at least 1 command,
	(so "__start_slash" will be generated by GCC) before it can use slash as a dependency.
    But when combined with 'weak' the value will be NULL, instead of linking with the sections in CSH. */
extern struct slash_command __start_slash __attribute__((visibility("hidden"), weak));
extern struct slash_command __stop_slash __attribute__((visibility("hidden"), weak));

#ifdef SLASH_USE_LINKED_SECTIONS
typedef struct slash_section_s {
	struct slash_command * section_start;
	struct slash_command * section_stop;
	struct slash_section_s * next;
} slash_section_t;

extern slash_section_t our_slash_section __attribute__((visibility("hidden")));
extern slash_section_t * slash_section_head __attribute__((visibility("hidden")));

/* Iteration of command list */
#define slash_for_each_command(_c) \
	struct slash_command *_c;\
    for (slash_section_t *section = slash_section_head; section != NULL; section = section->next) \
        for (_c = section->section_stop - 1; _c >= section->section_start; _c--)
#endif